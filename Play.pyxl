Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPRITE_SHEETS = [
    engineer_sprite,
    engineer_sprite,
    engineer_sprite,
    engineer_sprite,
]

const DIR_D = 0
const DIR_L = 1
const DIR_R = 2
const DIR_U = 3

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(4, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction. See workaround in player_simulate().
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def player_simulate(player):
    with next_vel, vel, pos, gamepad, speed, sprite_sheet, sprite, dir in player:
        // Record desired upcoming turns. Assign a new value each time so that
        // the cell-center code doesn't have to clone at every intersection
        
        // desired behavior:
        // - If we're already moving
        //   - ...and the same direction is already held, keep moving.
        //   - ...and the opposite direction is now held, then change direction instantly.
        //   - ...and an orthogonal direction is now held, then register next_vel and change
        //     direction at the center of the next cell.
        //   - ...and the dpad is released, stop at the center of the next empty cell
        // - If we're not moving, start moving in the desired direction immediately (or just
        //   turn if the path is blocked.
        // - never possible to move in both X and Y simultaneously
        if gamepad.xx:
            next_vel = xy(gamepad.xx * speed, 0)
        else if gamepad.yy:
            next_vel = xy(0, gamepad.yy * speed)
        // workaround for issue where quadplay will occasionally report the following
        // input states for three frames when a dpad is rapidly pushed in the opposite direction:
        //   frame N+0: .x=-1 .xx=+1 .dx=+1
        //   frame N+1: .x= 0 .xx= 0 .dx= 0
        //   frame N+2: .x=+1 .xx= 0 .dx=+1
        // The state at frame N+1 looks like "dpad released", which triggers the "stop" state.
        // So, we treat non-zero .x and .dx in the same as non-zero .xx
        else if gamepad.dx ≠ 0 and sign(gamepad.dx) == sign(gamepad.x):
            next_vel = xy(gamepad.x * speed, 0)
        else if gamepad.dy ≠ 0 and sign(gamepad.dy) == sign(gamepad.y):
            next_vel = xy(0, gamepad.y * speed)
        
        const at_center = at_cell_center(player)
        
        // If this is a legal place to do so, replace vel with next_vel
        if ((at_center or (‖vel + next_vel‖ < ε)) and // intersection or reverse
                // if the next line is commented out, you can steer into a wall to stop your movement
                // and face the fall. Otherwise, steering into a wall just registers the intent to
                // turn the next time there's a path in that direction.
                //is_cell_empty(pos, next_vel) and // not blocked
                ‖vel - next_vel‖ > ε): // changed
            vel = next_vel            
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(next_vel)|)

        // Determine facing direction
        const sv = sign(vel)
        if      sv.x == -1 and sv.y ==  0: dir = DIR_L
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_R
        else if sv.x ==  0 and sv.y == -1: dir = DIR_U
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_D

        // Stop moving at cell centers if no input is pressed
        if at_center and not is_zero(vel) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            next_vel = xy(0,0)

        // See if the move is possible, but only stop on centers
        if at_center and not is_cell_empty(pos, vel):
            // Hit wall. Stop moving
            vel = xy(0, 0)
        else:
            // Clear to move
            pos = pos + vel
        
        // Update player sprite
        const anim_frame = if is_zero(vel) then 0 else loop(floor(mode_frames/4), 4)
        sprite = sprite_sheet[anim_frame][dir]

let map = nil
let map_xform = xy(0,0)
let players = []

enter
────────────────────────────────────────────────────────────────────────

map = deep_clone(template_map)
map_xform = map_offset(map)
players = []
for i < 1:
    const sprite_sheet = PLAYER_SPRITE_SHEETS[i]
    push(players, make_entity({
        sprite_sheet:sprite_sheet,
        sprite:sprite_sheet[0][0],
        pos: BLOCK_SIZE * xy(1,1),
        gamepad: gamepad_array[i],
        vel:xy(0,0),
        next_vel:xy(0,0),
        dir:DIR_D,
        speed:1,
        }))

frame
────────────────────────────────────────────────────────────────────────

preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    iterate(players, player_simulate)
    iterate(players, draw_entity)
debug_watch(players[0].pivot)
