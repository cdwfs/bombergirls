Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPRITE_SHEETS = [
    engineer_sprite,
    engineer_sprite,
    engineer_sprite,
    engineer_sprite,
]
const BOMB_SPRITE = blocks_sprite[5][15]
const PLAYER_SPAWN_SPRITES = [
    map_tiles_sprite.start_p1,
    map_tiles_sprite.start_p2,
    map_tiles_sprite.start_p3,
    map_tiles_sprite.start_p4,
]
const FLOOR_SPRITE = map_tiles_sprite.floor

const DIR_S = 0
const DIR_W = 1
const DIR_E = 2
const DIR_N = 3

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(4, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0
def vec_str(v2):
    return "["+v2.x+","+v2.y+"]"

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction. See workaround in player_simulate().
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def player_simulate(player):
    with next_vel, vel, pos, gamepad, speed, sprite_sheet, sprite, dir in player:
        // Record desired upcoming turns. Assign a new value each time so that
        // the cell-center code doesn't have to clone at every intersection
        
        // desired behavior:
        // - If we're already moving
        //   - ...and the same direction is already held, keep moving.
        //   - ...and the opposite direction is now held, then change direction instantly.
        //   - ...and an orthogonal direction is now held, then register next_vel and change
        //     direction at the center of the next cell.
        //   - ...and the dpad is released, stop at the center of the next empty cell
        // - If we're not moving, start moving in the desired direction immediately (or just
        //   turn if the path is blocked.
        // - never possible to move in both X and Y simultaneously
        let sv = sign(vel)
        let sg = sign(xy(gamepad.x, gamepad.y))
        if |sg.x| > ε:
            next_vel = xy(sg.x * speed, 0)
        else if |sg.y| > ε:
            next_vel = xy(0, sg.y * speed)
        
        const at_center = at_cell_center(player)
        const next_vel_is_opposite = ‖vel + next_vel‖ < ε
        const next_vel_is_different = ‖vel - next_vel‖ > ε
        if (at_center or next_vel_is_opposite) and next_vel_is_different:
            vel = next_vel
            sv = sign(vel)
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(next_vel)|)
        // Determine facing direction
        if      sv.x == -1 and sv.y ==  0: dir = DIR_W
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_E
        else if sv.x ==  0 and sv.y == -1: dir = DIR_N
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_S
        else: dir = dir
        // Stop moving at cell centers if no dpad input
        if at_center and not is_zero(sv) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            sv = xy(0,0)
            next_vel = xy(0,0)
        // See if the move is possible, but only stop on centers
        if at_center and not is_cell_empty(pos, vel):
            // Hit wall. Stop moving
            vel = xy(0,0)
            sv = xy(0,0)
        else:
            // Clear to move
            pos = pos + vel
        assert(sv.x == 0 || sv.y == 0, "velocity " + vec_str(vel) + " must be all X or all Y")
        // Update player sprite
        const anim_frame = if is_zero(sv) then 0 else loop(floor(mode_frames/4), 4)
        sprite = sprite_sheet[anim_frame][dir]
        
        // place bombs
        if gamepad.aa and is_cell_empty(pos,vel):
            const c = map_pos_to_cell(pos)
            
            push(bombs, make_entity({
                sprite:BOMB_SPRITE,
                pos: BLOCK_SIZE*(c+vel),
                owner:0, // TODO: extract from player
                scale:xy(1,1),
                z:2,
                born_frame:mode_frames,
                }))
        debug_watch(size(bombs))
        if size(bombs) > 0:
            debug_watch(bombs[0])

def bomb_simulate(bomb):
    with pos, scale, born_frame, sprite in bomb:
        let s = 1 + 0.125*sin(π/12 * (mode_frames-born_frame))
        scale = xy(s,s)

// Declare mode variables
let map = nil
let map_xform = xy(0,0)
let players = []
let player_start_icells = []
let bombs = []
let static_entity_grid = []

enter
────────────────────────────────────────────────────────────────────────

// Initialize mode variables
map = deep_clone(template_map)
map_xform = map_offset(map)
players = []
player_start_icells = []
bombs = []
static_entity_grid = []

// Search map for starting cells
resize(player_start_icells, size(PLAYER_SPAWN_SPRITES))
for mx < map.size.x:
    for my < map.size.y:
        const ms = map[mx][my]
        for p < size(PLAYER_SPAWN_SPRITES):
            if ms == PLAYER_SPAWN_SPRITES[p]:
                player_start_icells[p] = xy(mx,my)
                set_map_sprite(map, xy(mx,my), FLOOR_SPRITE)

// Initialize static entity grid. TODO: not currently used
resize(static_entity_grid, map.size.x)
for x < map.size.x:
    let column = []
    resize(column, map.size.y)
    static_entity_grid[x] = column

for p < 1: // TODO: use player count
    const sprite_sheet = PLAYER_SPRITE_SHEETS[p]
    const spawn_icell = player_start_icells[p]
    let player_ent = make_entity({
        sprite_sheet:sprite_sheet,
        sprite:sprite_sheet[0][0],
        pos: BLOCK_SIZE * spawn_icell,
        gamepad: gamepad_array[p],
        vel:xy(0,0),
        next_vel:xy(0,0),
        dir:DIR_S,
        speed:1,
        })
    push(players, player_ent)

frame
────────────────────────────────────────────────────────────────────────

preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    iterate(players, player_simulate)
    iterate(players, draw_entity)
    iterate(bombs, bomb_simulate)
    iterate(bombs, draw_entity)
