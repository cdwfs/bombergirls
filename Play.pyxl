Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPAWN_SPRITES = [
    map_tiles_sprite.start_p1,
    map_tiles_sprite.start_p2,
    map_tiles_sprite.start_p3,
    map_tiles_sprite.start_p4,
]
const FLOOR_SPRITE = map_tiles_sprite.floor

const DIR_S = 0
const DIR_W = 1
const DIR_E = 2
const DIR_N = 3
const OFFSET_FOR_DIR = [xy(0,1), xy(-1,0), xy(1,0), xy(0,-1)]

def enter_postgame_mode(data):
    reset_post_effects()
    set_mode(PostGame) because "Game ended"

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(4, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0
def vec_str(v2):
    return "["+v2.x+","+v2.y+"]"

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

// Construct an empty array iterable by array[x][y]
def make_array2d(w,h,val default nil):
    let arr = []
    resize(arr, w)
    for x < w:
        let column = []
        for y < h:
            push(column, val)
        arr[x] = column
    return arr
    
def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction.
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def make_bomber_entity(player):
    return make_entity({
        sprite_sheet: player.sprite_sheet,
        sprite: player.sprite_sheet[0][0],
        pos: BLOCK_SIZE * player.spawn_icell,
        gamepad: player.gamepad,
        player: player,
        vel: xy(0,0),
        next_vel: xy(0,0),
        dir: DIR_S,
        speed: 1,
        bomb_range: 1,
        max_active_bomb_count: 1,
        active_bomb_count: 0,
        })

// ACTIVE BOMBERS

// Determine bomber velocity and facing direction for this frame.
// target: active_bombers
// RO: map, bomber.pos, bomber.gamepad, bomber.speed, bomber.sprite_sheet
// RW: bomber.next_vel, bomber.vel, bomber.dir, bomber.sprite
def itor_active_bomber_update_velocity(bomber):
    // desired behavior:
    // - If we're already moving
    //   - ...and the same direction is already held, keep moving.
    //   - ...and the opposite direction is now held, then change direction instantly.
    //   - ...and an orthogonal direction is now held, then register next_vel and change
    //     direction at the center of the next cell.
    //   - ...and the dpad is released, stop at the center of the next empty cell
    // - If we're not moving, start moving in the desired direction immediately (or just
    //   turn if the path is blocked.
    // - never possible to move in both X and Y simultaneously
    with next_vel, vel, gamepad, speed, dir, sprite, sprite_sheet in bomber:
        // Record desired upcoming turns based on gamepad state
        let sv = sign(vel)
        let sg = sign(xy(gamepad.x, gamepad.y))
        if |sg.x| > ε:
            next_vel = xy(sg.x * speed, 0)
        else if |sg.y| > ε:
            next_vel = xy(0, sg.y * speed)
        
        // TODO: figure out why this causes bombers to fly off through walls. Something
        // about the speed changing mid-game violates some assumptions?
        //speed = if gamepad.b ≠ 0 then 2 else 1
        
        const at_center = at_cell_center(bomber)
        const vel_dir = direction(vel)
        const next_vel_dir = direction(next_vel)
        const next_vel_is_opposite = ‖vel_dir + next_vel_dir‖ < ε
        const next_vel_is_different = ‖vel_dir - next_vel_dir‖ > ε
        if (at_center or next_vel_is_opposite) and next_vel_is_different:
            vel = next_vel
            sv = sign(vel)
        // Determine facing direction
        if      sv.x == -1 and sv.y ==  0: dir = DIR_W
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_E
        else if sv.x ==  0 and sv.y == -1: dir = DIR_N
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_S
        // otherwise, keep current direction
        
        // Stop moving at cell centers if no dpad input
        if at_center and not is_zero(sv) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            sv = xy(0,0)
            next_vel = xy(0,0)

        // Update bomber sprite
        const anim_frame = if is_zero(sv) then 0 else loop(floor(mode_frames/4), 4)
        sprite = sprite_sheet[anim_frame][dir]

// Apply current velocity to bomber position, taking into account obstacles that block movement.
// target: active_bombers
// RO: bomb_grid, box_grid
// RW: bomber.pos, bomber.vel
def itor_active_bomber_move(bomber):
    const at_center = at_cell_center(bomber)
    with vel, pos in bomber:
        let sv = sign(vel)
        // bombs stop movement halfway into the bomb's cell
        const icell = map_pos_to_cell(pos)
        const fcell = xy((pos.x/BLOCK_SIZE.x) % 1.0, (pos.y/BLOCK_SIZE.y) % 1.0)
        let blocked_by_bomb = false
        if fcell.x ≥ 0.5 and sv.x > 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if 0 < fcell.x and fcell.x < 0.5 and sv.x < 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if fcell.y ≥ 0.5 and sv.y > 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if 0 < fcell.y and fcell.y < 0.5 and sv.y < 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        // See if the move is possible, but only stop on centers
        if at_center and (not is_cell_empty(pos, vel) or box_grid[icell.x+sv.x][icell.y+sv.y]):
            // Hit wall. Stop moving
            vel = xy(0,0)
            sv = xy(0,0)
        else if blocked_by_bomb:
            // don't move. Don't clear velocity either, which seems risky?
        else:
            // Clear to move
            pos = pos + vel
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(vel)|)
        assert(sv.x == 0 || sv.y == 0, "velocity " + vec_str(vel) + " must be all X or all Y")

// Allow bombers to place bombs
// RO: bomber.gamepad, bomber.pos, mode_frames, bomber.max_active_bomb_count, bomber.bomb_range
// RW: bomb_grid, bomber.active_bomb_count
def itor_active_bomber_place_bomb(bomber):
    // place bombs
    // desired behavior:
    // - bombs are always placed at the center of a cell
    // - can't place a bomb in a cell that already has one
    // - bombs are placed on the player's current cell.
    //   - a player in the cell where a bomb is placed can move OUT of that cell,
    //     but not back in again.
    //   - a player can never move INTO a cell with a bomb.
    //   - if a player is mostly into a new cell, the bomb will be placed in front
    //     of them, such that it can be immediately kicked (or block further movement)
    // - The collision radius for bombs is effectively ½ as large as a full cell.
    //   - This means a player can move partway into a cell with a bomb, and can
    //     be trapped between two bombs in a corridor.
    //   - Does this mean a player could move between bombs in an open space?
    //     - No, orthogonal directional changes are only possible at cell centers. If
    //       a player's forward movement is blocked by a bomb, the only direction they
    //       can move is away (which may be into a cell that's ALSO blocked by a bomb)
    if bomber.active_bomb_count ≥ bomber.max_active_bomb_count:
        return
    const icell = map_pos_to_cell(bomber.pos)
    if bomber.gamepad.aa and is_cell_empty(bomber.pos) and not bomb_grid[icell.x][icell.y]:
        play_sound(SND_BOMB_PLACE)
        push(bombs, make_entity({
            sprite: BOMB_SPRITE,
            pos: BLOCK_SIZE*icell,
            scale: xy(1,1),
            z: 2,
            born_frame: mode_frames,
            fuse_frames: 120,
            range: bomber.bomb_range,
            bomber: bomber,
            }))
        bomber.active_bomb_count += 1
        bomb_grid[icell.x][icell.y] = true

// Check for player death conditions. If true, move from active_bombers and add to dead_bombers.
// target: active_bombers
// RO: bomber.pos, explosion_grid, mode_frames
// RW: bomber.death_frame, dead_bombers
def itor_active_bomber_kill(bomber):
    const icell = map_pos_to_cell(bomber.pos)
    if explosion_grid[icell.x][icell.y]:
        play_sound(SND_BOMBER_DEATH)
        delay(play_sound, 120, SND_BOMBER_DEATH2)
        push(dead_bombers, make_entity({
            pos: bomber.pos,
            sprite: death_sprite[0][0],
            z: bomber.z,
            death_time: mode_frames,
            player: bomber.player,
            }))
        return iterate.REMOVE

// DEAD BOMBERS

// Process a dead bomber
// target: dead_bombers
// RO: bomber.death_time, bomber.player
// RW: bomber.sprite, bomber.opacity, active_bombers, player.bomber, player.eliminated
def itor_dead_bomber_process(corpse):
    const age = mode_frames - corpse.death_time
    if age > 180:
        // corpse has finally died
        const player = corpse.player
        if player.lives == 0:
            // player is out of lives
            player.eliminated = true
        else:
            // spawn new bomber for this player
            player.lives = max(0, player.lives-1)
            let new_bomber = make_bomber_entity(corpse.player)
            push(active_bombers, new_bomber)
            player.bomber = new_bomber
        return iterate.REMOVE
    let frame = floor(clamp((age-120)/5, 0, 3))
    corpse.sprite = death_sprite[frame][0]
    corpse.opacity = clamp((180-age)/60,0,1)
    
// BOMBS

// Add all unexploded bombs to the bomb grid
// target: bombs
// RO: bomb.pos
// RW: bomb_grid
def itor_bomb_populate_grid(bomb):
    const icell = map_pos_to_cell(bomb.pos)
    bomb_grid[icell.x][icell.y] = true

// animate unexploded bombs
// target: bombs
// RO: bomb.born_frame, mode_frames
// RW: bomb.scale, bomb.sprite
def itor_bomb_animate(bomb):
    const age = mode_frames - bomb.born_frame
    const ttl = bomb.fuse_frames - age
    // pulse bomb scale
    let s = 1 + 0.125*sin(π/12 * age)
    bomb.scale = xy(s,s)
    // flash with increasing frequency as explosion nears
    if ttl ≤ 30:
        bomb.sprite = if (round(ttl/3)%2 == 0) then BOMB_FLASH_SPRITE else BOMB_SPRITE
    
// Detonate any bombs whose time has come. This will remove them from the bombs array
// and spawn explosion entities.
// target: bombs
// RO: bomb.born_frame, mode_frames, bomb.fuse_frames, bomb.pos, bomb.range, explosion_grid
// RW: explosions, bomb_grid
def itor_bomb_explode(bomb):
    const age = mode_frames - bomb.born_frame
    const ttl = bomb.fuse_frames - age
    const icell = map_pos_to_cell(bomb.pos)
    if ttl ≤ 0 or explosion_grid[icell.x][icell.y]:
        // explode
        play_sound(SND_BOMB_EXPLODE)
        const GROW_TIME = 5
        push(explosions, make_entity({
            pos: bomb.pos,
            born_frames: mode_frames,
            range: bomb.range, // how many child exposions to spawn in each direction (0+)
            is_center: true,
            duration: (bomb.range+4)*GROW_TIME, // how long before this explosion disappears
            grow_time: GROW_TIME, // how long before this explosion grows
            sprite: map_tiles_sprite[0][2],
            z: 2,
            }))
        bomb_grid[icell.x][icell.y] = false
        bomb.bomber.active_bomb_count = max(0, bomb.bomber.active_bomb_count-1)
        return iterate.REMOVE

// EXPLOSIONS

// Add all explosion entities to the explosion_grid
// target: explosions
// RO: expl.pos
// RW: explosion_grid
def itor_explosion_populate_grid(expl):
    const icell = map_pos_to_cell(expl.pos)
    explosion_grid[icell.x][icell.y] = true

// helper for grow_explosions()
const ANGLE_FOR_DIR = [-π/2, π, 0, π/2]
def add_child_explosion(parent, dir):
    const age = mode_frames - parent.born_frames
    const child_pos = parent.pos + OFFSET_FOR_DIR[dir]*BLOCK_SIZE
    // If there is a box in this cell, this explosion shouldn't grow any further.
    // The box-processing code will detect that there's an explosion in the same
    // cell as the box and trigger the box-destruction process.
    let child_range = parent.range - 1
    const icell = map_pos_to_cell(child_pos)
    if box_grid[icell.x][icell.y] or powerup_grid[icell.x][icell.y]:
        child_range = 0
    push(explosions, make_entity({
        pos: child_pos,
        z: parent.z,
        sprite: map_tiles_sprite[2][2],
        angle: ANGLE_FOR_DIR[dir],
        born_frames: mode_frames,
        range: child_range,
        duration: parent.duration-age,
        grow_time: parent.grow_time,
        grow_dir: dir,
        }))

// Grow explosions, adding new explosion entities to the end of the array.
// RO: map, mode_frames, expl.pos, expl.born_frames, expl.grow_time,
//     expl.is_center, expl.grow_dir, expl.duration, box_grid, powerup_grid
// RW: expl.sprite, expl.range
def grow_explosions(explosions):
    const explosion_count = size(explosions)
    for i < explosion_count:
        let expl = explosions[i]
        const age = mode_frames - expl.born_frames
        if age > expl.grow_time and expl.range > 0:
            if expl.is_center:
                expl.sprite = map_tiles_sprite[1][2] // swap center sprite to 4-way intersection
                // repeat for each direction
                for dir < 4:
                    const offset = OFFSET_FOR_DIR[dir]
                    if is_cell_empty(expl.pos, offset):
                        add_child_explosion(expl, dir)
            else:
                expl.sprite = map_tiles_sprite[3][2] // swap center sprite to 2-way intersection
                const offset = OFFSET_FOR_DIR[expl.grow_dir]
                if is_cell_empty(expl.pos, offset):
                    add_child_explosion(expl, expl.grow_dir)
            expl.range = 0 // prevent future growth. TODO: add to new non-growing explosion list?
            
// Cause explosions to fade out over time, and eventually be deleted.
// target: explosions
// RO: mode_frames, expl.born_frames, expl.duration
// RW: explosions, expl.opacity
def itor_explosion_fade_out(expl):
    const age = mode_frames - expl.born_frames
    const ttl = expl.duration - age
    if ttl ≤ 0:
        return iterate.REMOVE
    expl.opacity = clamp(ttl/15, 0, 1)

// BOXES

// Break boxes that have been hit by explosions.
// target: boxes
// RO: explosion_grid, box.pos, box.z
// RW: boxes, breaking_boxes
def itor_box_break(box):
    const icell = map_pos_to_cell(box.pos)
    if explosion_grid[icell.x][icell.y]:
        play_sound(SND_BOX_BREAK)
        push(breaking_boxes, make_entity({
            sprite: map_tiles_sprite[1][3],
            pos: box.pos,
            z: box.z+1
            }))
        return iterate.REMOVE
        
// Destroy breaking boxes once the explosion is gone
// target: boxes
// RO: explosion_grid, bbox.pos
// RW: breaking_boxes, box_grid, powerups
def itor_breaking_box_destroy(bbox):
    const icell = map_pos_to_cell(bbox.pos)
    if not explosion_grid[icell.x][icell.y]:
        box_grid[icell.x][icell.y] = false
        // sometimes, spawn a power-up!
        const roll = ξ
        if roll < 0.2:
            push(powerups, make_entity({
                sprite:map_tiles_sprite[2][3], // +bombs
                pos:bbox.pos,
                inc_bombs: 1,
                size: xy(14,14),
                z:bbox.z
                }))
        else if roll < 0.4:
            push(powerups, make_entity({
                sprite:map_tiles_sprite[3][3], // +range
                pos:bbox.pos,
                inc_range: 1,
                size: xy(14,14),
                z:bbox.z
                }))
        return iterate.REMOVE

// POWER-UPS
// - power-ups do not block movement. They disappear when touched, and the first player to touch them
//   gets the power-up.
// - power-ups DO block bomb explosions, just like boxes. An explosion that would pass through a power-up
//   stops instead.
// - power-ups ARE destroyed by bomb explosions, just like boxes. There is no visual indication (unlike
//   boxes, which switch to a breaking box sprite when struck by an explosion). But once the explosion is
//   cleared from a cell, any power-ups in that cell are removed as well.
// - Collecting a power-up while it's being destroyed by a bomb? Test in xblast, but the easiest answer
//   would be "you collect the power-up, and then instantly you're in a cell with an explosion and you die",
//   which is probably fine.
//   - xblast explosions disappear VERY quickly once they reach full radius, so it's difficult to test.

// Add all powerup entities to the powerup_grid
// target: powerups
// RO: pup.pos
// RW: powerup_grid
def itor_powerup_populate_grid(pup):
    const icell = map_pos_to_cell(pup.pos)
    powerup_grid[icell.x][icell.y] = true

// Handle powerups that are touched by players
// target: powerups
// RO: pup.pos, pup.shape, bomber.pos, bomber.shape, pup.inc_bombs, pup.inc_range
// RW: powerups, active_bomber.max_active_bomb_count
def itor_powerup_pickup(pup):
    for bomber in active_bombers:
        if overlaps(pup, bomber):
            play_sound(SND_POWERUP_PICKUP)
            bomber.max_active_bomb_count += if pup.inc_bombs then pup.inc_bombs else 0
            bomber.bomb_range += if pup.inc_range then pup.inc_range else 0
            return iterate.REMOVE

// Break powerups that have been hit by explosions.
// target: powerups
// RO: explosion_grid, pup.pos
// RW: pup.broken
def itor_powerup_break(pup):
    const icell = map_pos_to_cell(pup.pos)
    if explosion_grid[icell.x][icell.y]:
        pup.broken = true

// Destroy breaking powerups once the explosion is gone
// target: powerups
// RO: explosion_grid, pup.pos, pup.broken
// RW: powerups, powerup_grid
def itor_powerup_destroy(pup):
    if pup.broken:
        const icell = map_pos_to_cell(pup.pos)
        if not explosion_grid[icell.x][icell.y]:
            powerup_grid[icell.x][icell.y] = false
            return iterate.REMOVE


// GLOBALS
let map = nil
let map_xform = xy(0,0)
let players = []
let active_bombers = []
let dead_bombers = []
let bombs = []
let bomb_grid = []
let explosions = []
let explosion_grid = []
let boxes = []
let breaking_boxes = []
let box_grid = []
let powerups = []
let powerup_grid = []

enter(player_infos)
────────────────────────────────────────────────────────────────────────

// Initialize mode variables
map = deep_clone(template_map)
map_xform = map_offset(map)
players = []
active_bombers = []
dead_bombers = []
bombs = []
bomb_grid = []
explosions = []
explosion_grid = []
boxes = []
breaking_boxes = []
box_grid = []
powerups = []
powerup_grid = []

// In debug mode, we bypass the main menu and jump straight to play mode.
// Set reasonable defaults.
if get_previous_mode() == ∅:
    debug_print("Debug mode!")

// Search map for starting cells, so we can look them up by player index
let player_start_icells = []
resize(player_start_icells, size(PLAYER_SPAWN_SPRITES))
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        for p < size(PLAYER_SPAWN_SPRITES):
            if ms == PLAYER_SPAWN_SPRITES[p]:
                player_start_icells[p] = icell
                // overwrite the map cell with a normal floor sprite.
                set_map_sprite(map, icell, FLOOR_SPRITE)

// Search map for box cells, replace them with floors, and spawn box entities
box_grid = make_array2d(map.size.x, map.size.y, false)
for mx < map.size.x:
    for my < map.size.y:
        const icell = xy(mx,my)
        const ms = map[mx][my]
        if ms == map_tiles_sprite.block:
            const cell_pos = map_cell_to_pos(icell)
            push(boxes, make_entity({
                sprite: map_tiles_sprite[0][3],
                pos: cell_pos,
                z: 2,
                }))
            box_grid[icell.x][icell.y] = true
            set_map_sprite(map, icell, FLOOR_SPRITE)

// Create players and bombers
for info in player_infos:
    if info == ∅:
        continue
    const player_index = info.gamepad.index
    // store a separate player object, for state that persists across lives
    push(players, {
        lives: 3,
        spawn_icell: player_start_icells[player_index],
        sprite_sheet: info.sprite_sheet,
        gamepad: info.gamepad,
        bomber: nil,
        })
debug_watch(players)
for player in players:
    // spawn bombers
    let bomber = make_bomber_entity(player)
    push(active_bombers, bomber)
    player.bomber = bomber
    player.lives -= 1

frame
────────────────────────────────────────────────────────────────────────

const LIVES_STR = ["   ", "*  ", "** ", "***"]
draw_text({font:font, pos:xy(2% SCREEN_SIZE.x, 10% SCREEN_SIZE.y), text:"P1 " + LIVES_STR[players[0].lives], x_align:"left", color:#f5a})
draw_text({font:font, pos:xy(98% SCREEN_SIZE.x, 10% SCREEN_SIZE.y), text:"P2 " + LIVES_STR[players[1].lives], x_align:"right", color:#0af})

// SIMULATE
// Explode bombs, potentially creating explosions
iterate(bombs, itor_bomb_explode)
// grow and fade explosions
grow_explosions(explosions)
iterate(explosions, itor_explosion_fade_out)
explosion_grid = make_array2d(map.size.x, map.size.y, false)
iterate(explosions, itor_explosion_populate_grid)
// break boxes hit by explosions
iterate(boxes, itor_box_break)
iterate(breaking_boxes, itor_breaking_box_destroy)
// process powerups, which may also be destroyed by explosions
powerup_grid = make_array2d(map.size.x, map.size.y, false)
iterate(powerups, itor_powerup_populate_grid)
iterate(powerups, itor_powerup_pickup)
iterate(powerups, itor_powerup_break)
iterate(powerups, itor_powerup_destroy)
// Populate the bomb grid, including placing new bombs
bomb_grid = make_array2d(map.size.x, map.size.y, false)
iterate(bombs, itor_bomb_populate_grid)
iterate(active_bombers, itor_active_bomber_place_bomb)
// Kill bombers touching explosions
iterate(active_bombers, itor_active_bomber_kill)
// Process active bombers
iterate(active_bombers, itor_active_bomber_update_velocity)
iterate(active_bombers, itor_active_bomber_move)
// misc animation processing
iterate(dead_bombers, itor_dead_bomber_process)
iterate(bombs, itor_bomb_animate)
// Check for victory condition
let players_remaining = 0
debug_watch(players)
for player in players:
    if not player.eliminated:
        players_remaining += 1
if players_remaining ≤ 1:
    add_frame_hook(fade_out, enter_postgame_mode, 30, ∅, {})


// DRAW
preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    iterate(explosions, draw_entity)
    iterate(bombs, draw_entity)
    iterate(active_bombers, draw_entity)
    iterate(dead_bombers, draw_entity)
    iterate(boxes, draw_entity)
    iterate(breaking_boxes, draw_entity)
    iterate(powerups, draw_entity)

leave
────────────────────────────────────────────────────────────────────────
