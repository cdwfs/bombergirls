Play
════════════════════════════════════════════════════════════════════════

const BLOCK_SIZE = xy(16,16)
const PLAYER_SPRITE_SHEETS = [
    engineer_sprite,
    mage_sprite,
    rogue_sprite,
    warrior_sprite,
]
const BOMB_SPRITE = blocks_sprite[5][15]
const BOMB_FLASH_SPRITE = blocks_sprite[6][15]
const PLAYER_SPAWN_SPRITES = [
    map_tiles_sprite.start_p1,
    map_tiles_sprite.start_p2,
    map_tiles_sprite.start_p3,
    map_tiles_sprite.start_p4,
]
const FLOOR_SPRITE = map_tiles_sprite.floor

const DIR_S = 0
const DIR_W = 1
const DIR_E = 2
const DIR_N = 3
const OFFSET_FOR_DIR = [xy(0,1), xy(-1,0), xy(1,0), xy(0,-1)]

def map_offset(m):
    const screen_size_in_blocks = SCREEN_SIZE / BLOCK_SIZE
    const map_size_in_blocks = map.size
    return xy(4, 1) * BLOCK_SIZE

def map_pos_to_cell(pos):
    return round(pos / BLOCK_SIZE)

def map_cell_to_pos(cell):
    return BLOCK_SIZE * cell

def at_cell_center(entity):
    // Is this as close as we'll get to the center?
    const distance = |entity.pos - xy(round(entity.pos.x, BLOCK_SIZE.x),round(entity.pos.y, BLOCK_SIZE.y))|
    return max(distance.x, distance.y) < entity.speed

// gets the value of the map cell from a world-space coordinate.
// Only the sign of vel is used, to check the correct direction; its magnitude is ignored.
def map_sprite(pos, vel default xy(0, 0)):
    return get_map_sprite(map, map_pos_to_cell(pos) + sign(vel), 0)
    
def is_cell_empty(pos, vel default xy(0,0)):
    // Check map sprite
    if not map_sprite(pos, vel).can_walk:
        return false
    // TODO: Check for entity in cell
    return true
    
def is_zero(v2):
    return v2.x == 0 and v2.y == 0
def vec_str(v2):
    return "["+v2.x+","+v2.y+"]"

// Version of lerp() where t can be a vector
def vec_lerp(a, b, t):
    return (b - a) * t + a

// Construct an empty array iterable by array[x][y]
def make_array2d(w,h,val default nil):
    let arr = []
    resize(arr, w)
    for x < w:
        let column = []
        for y < h:
            push(column, val)
        arr[x] = column
    return arr
    
def is_dpad_pressed(gamepad):
    // checking just gamepad.x or gamepad.y isn't sufficient; when the opposite direction
    // is pressed, there is one frame where e.g. gamepad.xx is non-zero but gamepad.x is zero
    // TODO: not totally reliable it seems, as quadplay sometimes reports .x, .xx, and .dx as all zero
    // while dpad is in one direction. See workaround in player_simulate().
    return (gamepad.xx or gamepad.yy) or (gamepad.x or gamepad.y)

def player_simulate(player):
    with next_vel, vel, pos, gamepad, speed, sprite_sheet, sprite, dir in player:
        // Record desired upcoming turns. Assign a new value each time so that
        // the cell-center code doesn't have to clone at every intersection
        
        // TODO: figure out why this causes character to fly off through walls. Something
        // about the speed changing mid-game violates some assumptions?
        //speed = if gamepad.b ≠ 0 then 2 else 1
        
        // desired behavior:
        // - If we're already moving
        //   - ...and the same direction is already held, keep moving.
        //   - ...and the opposite direction is now held, then change direction instantly.
        //   - ...and an orthogonal direction is now held, then register next_vel and change
        //     direction at the center of the next cell.
        //   - ...and the dpad is released, stop at the center of the next empty cell
        // - If we're not moving, start moving in the desired direction immediately (or just
        //   turn if the path is blocked.
        // - never possible to move in both X and Y simultaneously
        let sv = sign(vel)
        let sg = sign(xy(gamepad.x, gamepad.y))
        if |sg.x| > ε:
            next_vel = xy(sg.x * speed, 0)
        else if |sg.y| > ε:
            next_vel = xy(0, sg.y * speed)
        
        const at_center = at_cell_center(player)
        const next_vel_is_opposite = ‖vel + next_vel‖ < ε
        const next_vel_is_different = ‖vel - next_vel‖ > ε
        if (at_center or next_vel_is_opposite) and next_vel_is_different:
            vel = next_vel
            sv = sign(vel)
            // Snap to a pixel on the axis that we're not moving along
            // to prevent error from accumulating
            pos = vec_lerp(round(pos), pos, |sign(next_vel)|)
        // Determine facing direction
        if      sv.x == -1 and sv.y ==  0: dir = DIR_W
        else if sv.x ==  1 and sv.y ==  0: dir = DIR_E
        else if sv.x ==  0 and sv.y == -1: dir = DIR_N
        else if sv.x ==  0 and sv.y ==  1: dir = DIR_S
        else: dir = dir
        // Stop moving at cell centers if no dpad input
        if at_center and not is_zero(sv) and not is_dpad_pressed(gamepad):
            vel = xy(0,0)
            sv = xy(0,0)
            next_vel = xy(0,0)
        // bombs stop movement halfway into the bomb's cell
        const icell = map_pos_to_cell(pos)
        const fcell = xy((pos.x/BLOCK_SIZE.x) % 1.0, (pos.y/BLOCK_SIZE.y) % 1.0)
        let blocked_by_bomb = false
        if fcell.x ≥ 0.5 and sv.x > 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if 0 < fcell.x and fcell.x < 0.5 and sv.x < 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if fcell.y ≥ 0.5 and sv.y > 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        if 0 < fcell.y and fcell.y < 0.5 and sv.y < 0 and bomb_grid[icell.x][icell.y]: blocked_by_bomb = true
        // See if the move is possible, but only stop on centers
        if at_center and not is_cell_empty(pos, vel):
            // Hit wall. Stop moving
            vel = xy(0,0)
            sv = xy(0,0)
        else if blocked_by_bomb:
            // don't move. Don't clear velocity either, which seems risky.
        else:
            // Clear to move
            pos = pos + vel
        assert(sv.x == 0 || sv.y == 0, "velocity " + vec_str(vel) + " must be all X or all Y")
        // Update player sprite
        if not player.dead:
            const anim_frame = if is_zero(sv) then 0 else loop(floor(mode_frames/4), 4)
            sprite = sprite_sheet[anim_frame][dir]

        // Check for player death
        if explosion_grid[icell.x][icell.y] and not player.dead:
            player.dead = true
            player.death_time = mode_frames
            player.sprite = death_sprite[0][0]
        if player.dead and mode_frames - player.death_time > 120:
            let frame = floor(clamp(((mode_frames - player.death_time)-120) / 5, 0, 3))
            player.sprite = death_sprite[frame][0]
            player.opacity = clamp((180-(mode_frames - player.death_time))/60,0,1)
        if player.dead and mode_frames - player.death_time > 180:
            return iterate.REMOVE

        // place bombs
        // desired behavior:
        // - bombs are always placed at the center of a cell
        // - can't place a bomb in a cell that already has one
        // - bombs are placed on the player's current cell.
        //   - a player in the cell where a bomb is placed can move OUT of that cell,
        //     but not back in again.
        //   - a player can never move INTO a cell with a bomb.
        //   - if a player is mostly into a new cell, the bomb will be placed in front
        //     of them, such that it can be immediately kicked (or block further movement)
        // - The collision radius for bombs is effectively ½ as large as a full cell.
        //   - This means a player can move partway into a cell with a bomb, and can
        //     be trapped between two bombs in a corridor.
        //   - Does this mean a player could move between bombs in an open space?
        //     - No, orthogonal directional changes are only possible at cell centers. If
        //       a player's forward movement is blocked by a bomb, the only direction they
        //       can move is away (which may be into a cell that's ALSO blocked by a bomb)
        if gamepad.aa and is_cell_empty(pos) and not bomb_grid[icell.x][icell.y]:
            push(bombs, make_entity({
                sprite:BOMB_SPRITE,
                pos: BLOCK_SIZE*icell,
                owner:0, // TODO: extract from player
                scale:xy(1,1),
                z:2,
                born_frame:mode_frames,
                fuse_frames:120,
                range: 5,
                }))
            // mark cell in bomb_grid as bomb-y
            bomb_grid[icell.x][icell.y] = true


def bomb_simulate(bomb):
    const age = mode_frames-bomb.born_frame
    const ttl = bomb.fuse_frames - age
    with scale in bomb:
        // animate bomb
        let s = 1 + 0.125*sin(π/12 * age)
        scale = xy(s,s)
    const icell = map_pos_to_cell(bomb.pos)
    if ttl ≤ 0 or explosion_grid[icell.x][icell.y]:
        // explode
        push(explosions, make_entity({
            pos: bomb.pos,
            born_frames: mode_frames,
            range:bomb.range, // how many child exposions to spawn in each direction (0+)
            is_center:true,
            duration:60, // how long before this explosion disappears
            grow_time:5, // how long before this explosion grows
            sprite:map_tiles_sprite[0][2],
            z:2,
            }))
        return iterate.REMOVE
    if ttl ≤ 30:
        // flash
        bomb.sprite = if (round(ttl/3)%2 == 0) then BOMB_FLASH_SPRITE else BOMB_SPRITE
    // mark cell in bomb_grid as bomb-y
    bomb_grid[icell.x][icell.y] = true

const ANGLE_FOR_DIR = [-π/2, π, 0, π/2]
def add_child_explosion(parent, dir):
    const age = mode_frames - parent.born_frames
    const child_pos = parent.pos + OFFSET_FOR_DIR[dir]*BLOCK_SIZE
    push(new_child_explosions, make_entity({
        pos:child_pos,
        z:parent.z,
        sprite:map_tiles_sprite[3][2],
        angle:ANGLE_FOR_DIR[dir],
        born_frames:mode_frames,
        range:parent.range-1,
        duration:parent.duration-age,
        grow_time:parent.grow_time,
        grow_dir:dir,
        }))
    // mark cell in explosion_grid as explode-y
    const icell = map_pos_to_cell(child_pos)
    explosion_grid[icell.x][icell.y] = true

def explosion_simulate(expl):
    const age = mode_frames - expl.born_frames
    if age > expl.grow_time and expl.range > 0:
        if expl.is_center:
            expl.sprite = map_tiles_sprite[1][2] // swap center sprite to 4-way intersection
            // repeat for each direction
            for dir < 4:
                const offset = OFFSET_FOR_DIR[dir]
                if is_cell_empty(expl.pos, offset):
                    add_child_explosion(expl, dir)
        else:
            expl.sprite = map_tiles_sprite[2][2] // swap center sprite to 2-way intersection
            const offset = OFFSET_FOR_DIR[expl.grow_dir]
            if is_cell_empty(expl.pos, offset):
                add_child_explosion(expl, expl.grow_dir)
        expl.range = 0 // prevent future growth
    const ttl = expl.duration - age
    if ttl ≤ 0:
        return iterate.REMOVE
    expl.opacity = clamp(ttl/15, 0, 1)
    // mark cell in explosion_grid as explode-y
    const icell = map_pos_to_cell(expl.pos)
    explosion_grid[icell.x][icell.y] = true

// Declare mode variables
let map = nil
let map_xform = xy(0,0)
let players = []
let player_start_icells = []
let bombs = []
let explosions = []
let new_child_explosions = [] // can't modify explosions while iterating
let explosion_grid = []
let bomb_grid = []

enter
────────────────────────────────────────────────────────────────────────

// Initialize mode variables
map = deep_clone(template_map)
map_xform = map_offset(map)
players = []
player_start_icells = []
bombs = []
explosions = []
new_child_explosions = []
explosion_grid = []
bomb_grid = []

// Search map for starting cells
resize(player_start_icells, size(PLAYER_SPAWN_SPRITES))
for mx < map.size.x:
    for my < map.size.y:
        const ms = map[mx][my]
        for p < size(PLAYER_SPAWN_SPRITES):
            if ms == PLAYER_SPAWN_SPRITES[p]:
                player_start_icells[p] = xy(mx,my)
                set_map_sprite(map, xy(mx,my), FLOOR_SPRITE)

for p < 2: // TODO: use player count
    const sprite_sheet = PLAYER_SPRITE_SHEETS[p]
    const spawn_icell = player_start_icells[p]
    let player_ent = make_entity({
        sprite_sheet:sprite_sheet,
        sprite:sprite_sheet[0][0],
        pos: BLOCK_SIZE * spawn_icell,
        gamepad: gamepad_array[p],
        vel:xy(0,0),
        next_vel:xy(0,0),
        dir:DIR_S,
        speed:1,
        })
    push(players, player_ent)

frame
────────────────────────────────────────────────────────────────────────

preserving_transform:
    set_transform(map_xform)
    draw_map({map:map})
    // Offset by ½ a grid square so that we can use integer coordinates for the centers of grid tiles
    compose_transform(0.5 BLOCK_SIZE)
    // explosions
    explosion_grid = make_array2d(map.size.x, map.size.y, false)
    iterate(explosions, explosion_simulate)
    extend(explosions, new_child_explosions)
    new_child_explosions = []
    iterate(explosions, draw_entity)
    // bombs
    bomb_grid = make_array2d(map.size.x, map.size.y, false)
    iterate(bombs, bomb_simulate)
    iterate(bombs, draw_entity)
    // players
    iterate(players, player_simulate)
    iterate(players, draw_entity)
